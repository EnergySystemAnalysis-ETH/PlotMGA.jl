var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#PlotMGA.EnergyUnit","page":"API","title":"PlotMGA.EnergyUnit","text":"EnergyUnit MWh=1 GWh=1000\n\nThe multiplicities of SpineOpt's native flow unit - MWh\n\n\n\n\n\n","category":"type"},{"location":"api/#PlotMGA.ProfileType","page":"API","title":"PlotMGA.ProfileType","text":"struct ProfileType\n    name::String # profile name\n    df_predicate::Pair # df filter predicate\nend\n\nDescribes a single flow profile. The predicate greps all of the flows from a master flow df.\n\nExample\n\ntype1 = ProfileType(\"Electricity\", :destination=>ByRow(contains(\"Electricity\")))\n\ntype2 = ProfileType(\"Heat\", :destination=>ByRow(contains(\"Space_Heating\")))\n\ndf_electricity = subset(master_df, type1.df_predicate)\n\ndf_heat = subset(master_df, type2.df_predicate)\n\n\n\n\n\n","category":"type"},{"location":"api/#PlotMGA.add_mga_iteration-Tuple{DataFrames.DataFrame}","page":"API","title":"PlotMGA.add_mga_iteration","text":"add_mga_iteration(params::DataFrame)\n\nAdds mga_iteration with the MGA iteration number to a df with details of a SpineOpt's entity.\n\nThe SpineOpt's MGA data should always the last entry in details, with a format \"mgaitNUMBER\".\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.annotate_df_by_profiles-Tuple{Any, Vector{PlotMGA.CombinedProfileTypes}}","page":"API","title":"PlotMGA.annotate_df_by_profiles","text":"annotate_df_by_profiles(df, combined_profiles::Vector{CombinedProfileTypes})\n\nAdds a column type based on fulfilling the combined profile predicates.\n\nThe entries not fulfilling any predicates will be discarded. \n\nEntries fulfilling multiple combinations will be multiplied.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.annotate_optimal_solutions-Tuple{Any}","page":"API","title":"PlotMGA.annotate_optimal_solutions","text":"annotate_optimal_solutions(df)\n\nChanges the alternative field for optimal solutions from the MGA process.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.by_pairs-Tuple{Any, Any}","page":"API","title":"PlotMGA.by_pairs","text":"by_pairs(df, group_cols)\n\nGroups df and create the iterator in the form group_column_values, subdf\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.change_col_units-Tuple{Any, EnergyUnit, Symbol}","page":"API","title":"PlotMGA.change_col_units","text":"change_col_units(df, unit::EnergyUnit, column::Symbol)\n\nChanges the colums energy units to those passed.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.combine_profiles-Tuple{Vararg{Vector{ProfileType}}}","page":"API","title":"PlotMGA.combine_profiles","text":"combine_profiles(profile_types::Vector{ProfileType}...)\n\nProduces all combinations of flow profile types from multiple lists.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.connect_technology_with_effects-Tuple{Any, Any}","page":"API","title":"PlotMGA.connect_technology_with_effects","text":"connect_technology_with_effects(df, effects_df)\n\nAssigns total system effects to iterations from appropriate alternatives. \n\nFor example, connects technology installation with total system costs.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.get_spine_parameter-Tuple{Any, Symbol}","page":"API","title":"PlotMGA.get_spine_parameter","text":"get_spine_parameter(db, param_name::Symbol[, col_order])\n\nGrabs the parameter from a SpineOpt's database and processess it according to the parameter name.\n\nThe option parameter col_order specifies the only columns that should be in the output and their order. Those columns should be sortable.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.get_spine_parameter_value-Tuple{Any, Any}","page":"API","title":"PlotMGA.get_spine_parameter_value","text":"get_spine_parameter_value(db, param_name)\n\nGet parameter value from a db in a SpineDB format.\n\nReturns a df with columns:\n\nalternative - SpineDB alternative (e.g., used method)\nvalue - parameter value\ndetails - list of fields from the Spine's entity name (e.g., parameter name, mga iteration, technology)\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.obtain_technology_interactions-Tuple{Any, Any}","page":"API","title":"PlotMGA.obtain_technology_interactions","text":"obtain_technology_interactions(df, effects_df)\n\nProduces a df describing a matrix of interactions between different technology installations and their effects (e.g., total system costs).\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.plot_all_mga_profiles-Tuple{Any, EnergyUnit, Vararg{Vector{ProfileType}}}","page":"API","title":"PlotMGA.plot_all_mga_profiles","text":"plot_all_mga_profiles(\n    df, unit::EnergyUnit, profile_types::Vector{ProfileType}...;\n    fig_prefix::String=\"\", display_plot::Bool=true, save_plot::Bool=true\n)\n\nPlots all profiles for every flow type combination and every alternative from the df column alternative.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.plot_mga_alternative_profiles-Tuple{Any, EnergyUnit}","page":"API","title":"PlotMGA.plot_mga_alternative_profiles","text":"plot_mga_alternative_profiles(\n    df, unit::EnergyUnit;\n    fig_prefix::String=\"\", display_plot::Bool=true, save_plot::Bool=true\n)\n\nPlots flow profiles of a single type across all of the alternatives present in df field alternative.  Every alternative produces a single figure.\n\nIf the figures are to be saved fig_prefix is added to the filename.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.plot_mga_profile-Tuple{Any, EnergyUnit}","page":"API","title":"PlotMGA.plot_mga_profile","text":"plot_mga_profile(\n    df, unit::EnergyUnit;\n    iteration_col::Symbol=:mga_iteration, value_col::Symbol=:total_value, stackby::Symbol=:technology\n)\n\nPlots stacked flow profiles for a df describing a single MGA run.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.plot_technology_effects-Tuple{Any, Any}","page":"API","title":"PlotMGA.plot_technology_effects","text":"plot_technology_effects(\n    tech_df, effects_df;\n    fig_prefix::String=\"\", display_plot::Bool=true, save_plot::Bool=true\n)\n\nCreates a plot for every technology and show effects of its installation on the total system state (e.g., total system_costs)\n\nIf the figures are to be saved fig_prefix is added to the filename.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.plot_technology_effects_by_alternative-Tuple{Any, Any}","page":"API","title":"PlotMGA.plot_technology_effects_by_alternative","text":"plot_technology_effects_by_alternative(\n    df, plot;\n    technology_col::Symbol=:total_value, effect_col::Symbol=:total_value_effects\n)\n\nModifies the passed plot by adding point corresponding to the technology and its effects in every alternative.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.plot_technology_interactions-Tuple{Any, Any, AbstractDict}","page":"API","title":"PlotMGA.plot_technology_interactions","text":"plot_technology_interactions(\n    tech_df, effects_df, alternative_markers::AbstractDict;\n    fig_prefix::String=\"\", display_plot::Bool=true, save_plot::Bool=true\n)\n\nCreates a plot for every pair of the technologies, showing interactions between their installed capacities  and effects (e.g., total system costs). Every plot has entries from all of the alternatives from df.\n\nTo tell apart the alternatives, we have to pass Dict of markers.\n\nIf the figures are to be saved fig_prefix is added to the filename.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.plot_technology_interactions_by_alternative-Tuple{Any, Any, AbstractDict}","page":"API","title":"PlotMGA.plot_technology_interactions_by_alternative","text":"plot_technology_interactions_by_alternative(\n    df, plot, alternative_markers::AbstractDict;\n    x_technology_col::Symbol=:total_value_1st, y_technology_col::Symbol=:total_value_2nd, effect_col::Symbol=:total_value_effects\n)\n\nModifies the passed plot by adding point corresponding to the technology interactions per every alternative. The points are colored according to the effect_col from df.\n\nTo tell apart values from different alternatives (e.g., used algorithm) we have to pass dict of markers with an entry for each alternative.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.process_flows-Tuple{DataFrames.DataFrame}","page":"API","title":"PlotMGA.process_flows","text":"process_flows(params::DataFrame)\n\nAdds `destination` to a df with the `details` of a SpineOpt's entity, and keeps only inflows.\n\nThe MORPHE2US destination data should always comes as a third in `details`.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.process_spine_data-Tuple{Any}","page":"API","title":"PlotMGA.process_spine_data","text":"process_spine_data(::Val{DB_ENTRY}) where {DB_ENTRY}\n\nReturns processing pipeline for the database entry.\n\nIt currently has a specific implementation for:\n    - `total_costs`\n    - `storages_invested`\n    - `units_invested`\n    - `unit_flow`\n\nBut you can easily extend it on the go by defining:\n```julia\nfunction process_fn1(df)\n    ...\n    df\nend\nfunction process_fn2(df)\n    ...\n    df\nend\n```\nprocess_spine_data(::Val{:new_type}) = process_fn1 ∘ process_fn2\n\nSome of the predefined functions for processing include: \n    - `sum_timeseries`\n    - `add_mga_iteration`\n    - `process_technology`\n    - `process_flows`\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.process_technology-Tuple{DataFrames.DataFrame}","page":"API","title":"PlotMGA.process_technology","text":"process_technology(params::DataFrame)\n\nAdds technology and installation to a df with the details of a SpineOpt's entity.\n\nThe MORPHE2US technology data should always comes as a second in details, with a format \"TECHNOLOGY_NAME(B|D)LVL`INSTALLATIONSITE`\".\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.squash_groups-Tuple{Any, Any}","page":"API","title":"PlotMGA.squash_groups","text":"squash_groups(df, kept_cols[, combine_col])\n\nKeep only columns with unique values of kept_cols, and squash the rest.\n\nIf combine_cols is passed, the column values are summed. If not, only the first entry is retained.\n\n\n\n\n\n","category":"method"},{"location":"api/#PlotMGA.sum_timeseries-Tuple{DataFrames.DataFrame}","page":"API","title":"PlotMGA.sum_timeseries","text":"sum_timeseries(params::DataFrame)\n\nAdds total_value with sum of values to a df with value.\n\nEach of the values should be a Dict with datetime as keys and floats as values.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This page serves as a guide for running and customizing PlotMGA.jl. For a ready-made example see example/.","category":"page"},{"location":"manual/#Installation","page":"Manual","title":"Installation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PlotMGA.jl comes as a Julia Package, and can be installed using standard Pkg:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Pkg\nPkg.add(url=\"https://github.com/EnergySystemAnalysis-ETH/PlotMGA.jl\")","category":"page"},{"location":"manual/#Input-data","page":"Manual","title":"Input data","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PlotMGA.jl expects a database with result outputs produced by a SpineOpt's MGA run. It is preferrable if the Spine inputs were produced by the MORPHE2US pipeline.","category":"page"},{"location":"manual/#Comparing-MGA-algorithms","page":"Manual","title":"Comparing MGA algorithms","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"PlotMGA.jl has an inbuilt functionality for comparing different MGA algorithms/parameters with plots. Simply store multiple algorithms' results in a single database, but with a different Alternative value (e.g., name of the algorithm).","category":"page"},{"location":"manual/#Obtaining-values-to-plot","page":"Manual","title":"Obtaining values to plot","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"We have to first select the values that we want to plot, e.g., the technological installations and energy flows.","category":"page"},{"location":"manual/#Processing-our-results-(Optional)","page":"Manual","title":"Processing our results (Optional)","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"You might skip this paragraph if you are only interested in the SpineOpt's parameters from this list:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"units installed\nunit flows\ntotal costs\nstorages_invested","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"As SpineOpt's offers a great deal of flexibility for modeling, we might run into many different formats for our data. To solve this issue we give the user the option to model their preprocessing pipeline ad-hoc, with the help of DataFrames. The SpineDB keeps the data (after joining) in a format:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"entity.name - entry details delimited with \"__\"\nalternative\nvalue (BSON encoded timeseries)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We process those parameters and obtain a DataFrame with columns: ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"details - list\nalternative\nvalue - timeseries dict","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In order to setup processing of some new parameter type, simply use:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"function process_fn1(df)\n    ...\n    df\nend\nfunction process_fn2(df)\n    ...\n    df\nend\nprocess_spine_data(::Val{:new_type}) = process_fn1 ∘ process_fn2","category":"page"},{"location":"manual/#Getting-the-data","page":"Manual","title":"Getting the data","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To obtain the data DataFrames, we can use the  get_spine_parameter function:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"db = # Open DB handler\ndf1 = get_spine_parameter(db, :param_type) \ndf2 = get_spine_parameter(db, :param_type2, [col1, col2]) # leaves only the specified columns and sorts on them","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Examples:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"unit_flows = get_spine_parameter(db, :unit_flow, \n    [:mga_iteration, :alternative, :technology, :installation, :destination, :total_value])","category":"page"},{"location":"manual/#Plotting","page":"Manual","title":"Plotting","text":"","category":"section"},{"location":"manual/#Plotting-Profiles","page":"Manual","title":"Plotting Profiles","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can plot how the commodity flow profiles change in every MGA iteration. However, there are many profiles we might be interested in. In PlotMGA, we group the profiles, e.g., according to the commodity of the flow.  The group can be defined as:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"group1 = [\n    ProfileType(profile_name_1, df_filter_predicate_1),\n    ProfileType(profile_name_2, df_filter_predicate_2),\n    ...\n]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If we define many groups, the plotting will be done over all of the possible combinations of group entries.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Then we run:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"plot_all_mga_profiles(\n    energy_flows_df, energy_unit, group1, group2, ...,\n    fig_prefix=\"mga_profiles_\"\n)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"unit_flows = get_spine_parameter(db, :unit_flow, \n    [:mga_iteration, :alternative, :technology, :installation, :destination, :total_value])\ncommodity_types = [\n    ProfileType(\"Electricity\", :destination=>ByRow(contains(\"Electricity\"))),\n    ProfileType(\"Heat\", :destination=>ByRow(contains(\"Space_Heating\")))\n]\nplot_all_mga_profiles(\n    unit_flows, PlotMGA.GWh, commodity_types,\n    fig_prefix=\"mga_profiles_\"\n)","category":"page"},{"location":"manual/#Plotting-Technology-Effects","page":"Manual","title":"Plotting Technology Effects","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"We might be interest how our technology in MGA's iteration affect some total system parameters, e.g. CO2 production, costs:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"plot_technology_effects(technology_df, effects_df, fig_prefix=\"effects_\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"total_costs = get_spine_parameter(db, :total_costs, \n    [:mga_iteration, :alternative, :total_value])\nunits_invested = get_spine_parameter(db, :units_invested, \n    [:mga_iteration, :alternative, :technology, :installation, :total_value])\nplot_technology_effects(\n    units_invested, total_costs, \n    fig_prefix=\"technology_effects_on_cost_\"\n)","category":"page"},{"location":"manual/#Plotting-Technology-Interactions","page":"Manual","title":"Plotting Technology Interactions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can plot how the capacity of installed technology reacts with different technological installations, and thus on total system's parameters.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"As the plotting is done over every alternative in database (e.g., used algorithm) we have to define markers to differentiate between them. We have to also define the marker for the optimal solution:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"markers = Dict(\n    \"alg1\" => :x,\n    \"alg2\" => :rect,\n    \"Optimal\" => :diamond\n)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Then we can run:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"plot_technology_interactions(\n    technology_df, effects, markers, \n    fig_prefix=\"technology_interactions_\"\n)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Example","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"total_costs = get_spine_parameter(db, :total_costs, \n    [:mga_iteration, :alternative, :total_value])\nunits_invested = get_spine_parameter(db, :units_invested, \n    [:mga_iteration, :alternative, :technology, :installation, :total_value])\nmarkers = #define markers\nplot_technology_interactions(\n    units_invested, total_costs, markers, \n    fig_prefix=\"technology_interactions_\", display_plot=false\n)","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PlotMGA.jl","category":"page"},{"location":"#What-is-this-package-about?","page":"Home","title":"What is this package about?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PlotMGA.jl is a useful tool to plot MGA run results, obtained in the SpineOpt's environment. The data for Spine, should be produced using MORPHE2US package.","category":"page"}]
}
